'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = require('tslib');
var React = require('react');
var reactSpring = require('react-spring');
var useScrollLock = _interopDefault(require('use-scroll-lock'));

function usePrevious(value) {
    var ref = React.useRef(null);
    React.useEffect(function () {
        ref.current = value;
    }, [value]);
    return ref.current;
}

var canUseDOM = !!(typeof window !== "undefined" &&
    window.document &&
    window.document.createElement);
var isEnabled = false;
var MOUSE_MOVE_THRESHOLD = 1000;
var lastTouchTimestamp = 0;
function enableMouse() {
    if (isEnabled || Date.now() - lastTouchTimestamp < MOUSE_MOVE_THRESHOLD) {
        return;
    }
    isEnabled = true;
}
function disableMouse() {
    lastTouchTimestamp = Date.now();
    if (isEnabled) {
        isEnabled = false;
    }
}
if (canUseDOM) {
    document.addEventListener("touchstart", disableMouse, true);
    document.addEventListener("touchmove", disableMouse, true);
    document.addEventListener("mousemove", enableMouse, true);
}
function isMouseEnabled() {
    return isEnabled;
}

var initialState = {
    time: Date.now(),
    xy: [0, 0],
    delta: [0, 0],
    initial: [0, 0],
    previous: [0, 0],
    direction: [0, 0],
    initialDirection: [0, 0],
    local: [0, 0],
    lastLocal: [0, 0],
    velocity: 0,
    distance: 0
};
var defaultConfig = {
    enableMouse: true
};
var grantedTouch = null;
function useGestureResponder(options, config) {
    if (options === void 0) { options = {}; }
    if (config === void 0) { config = {}; }
    var state = React.useRef(initialState);
    var _a = tslib_1.__assign({}, defaultConfig, config), uid = _a.uid, enableMouse = _a.enableMouse;
    var id = React.useRef(uid || Math.random());
    var pressed = React.useRef(false);
    var callbackRefs = React.useRef(options);
    React.useEffect(function () {
        callbackRefs.current = options;
    }, [options]);
    function claimTouch(e) {
        if (grantedTouch && grantedTouch.onTerminationRequest(e)) {
            grantedTouch.onTerminate(e);
            grantedTouch = null;
        }
        attemptGrant(e);
    }
    function attemptGrant(e) {
        if (grantedTouch) {
            return;
        }
        grantedTouch = {
            id: id.current,
            onTerminate: onTerminate,
            onTerminationRequest: onTerminationRequest
        };
        onGrant(e);
    }
    function bindGlobalMouseEvents() {
        window.addEventListener("mousemove", handleMoveMouse, false);
        window.addEventListener("mousemove", handleMoveMouseCapture, true);
        window.addEventListener("mouseup", handleEndMouse);
    }
    function unbindGlobalMouseEvents() {
        window.removeEventListener("mousemove", handleMoveMouse, false);
        window.removeEventListener("mousemove", handleMoveMouseCapture, true);
        window.removeEventListener("mouseup", handleEndMouse);
    }
    function handleStartCapture(e) {
        updateStartState(e);
        pressed.current = true;
        var granted = onStartShouldSetCapture(e);
        if (granted) {
            attemptGrant(e);
        }
    }
    function handleStart(e) {
        updateStartState(e);
        pressed.current = true;
        bindGlobalMouseEvents();
        var granted = onStartShouldSet(e);
        if (granted) {
            attemptGrant(e);
        }
    }
    function isGrantedTouch() {
        return grantedTouch && grantedTouch.id === id.current;
    }
    function handleEnd(e) {
        pressed.current = false;
        unbindGlobalMouseEvents();
        if (!isGrantedTouch()) {
            return;
        }
        grantedTouch = null;
        onRelease(e);
    }
    function handleMoveCapture(e) {
        updateMoveState(e);
        if (isGrantedTouch()) {
            return;
        }
        if (onMoveShouldSetCapture(e)) {
            claimTouch(e);
        }
    }
    function handleMove(e) {
        if (isGrantedTouch()) {
            onMove(e);
            return;
        }
        if (onMoveShouldSet(e)) {
            claimTouch(e);
        }
    }
    function onStartShouldSet(e) {
        return callbackRefs.current.onStartShouldSet
            ? callbackRefs.current.onStartShouldSet(state.current, e)
            : false;
    }
    function onStartShouldSetCapture(e) {
        return callbackRefs.current.onStartShouldSetCapture
            ? callbackRefs.current.onStartShouldSetCapture(state.current, e)
            : false;
    }
    function onMoveShouldSet(e) {
        return callbackRefs.current.onMoveShouldSet
            ? callbackRefs.current.onMoveShouldSet(state.current, e)
            : false;
    }
    function onMoveShouldSetCapture(e) {
        return callbackRefs.current.onMoveShouldSetCapture
            ? callbackRefs.current.onMoveShouldSetCapture(state.current, e)
            : false;
    }
    function onGrant(e) {
        if (callbackRefs.current.onGrant) {
            callbackRefs.current.onGrant(state.current, e);
        }
    }
    function updateStartState(e) {
        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;
        var s = state.current;
        state.current = tslib_1.__assign({}, initialState, { lastLocal: s.lastLocal || initialState.lastLocal, xy: [pageX, pageY], initial: [pageX, pageY], previous: [pageX, pageY], time: Date.now() });
    }
    function updateMoveState(e) {
        var _a = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;
        var s = state.current;
        var time = Date.now();
        var x_dist = pageX - s.xy[0];
        var y_dist = pageY - s.xy[1];
        var delta_x = pageX - s.initial[0];
        var delta_y = pageY - s.initial[1];
        var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
        var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);
        var scaler = 1 / (len || 1);
        var velocity = len / (time - s.time);
        var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0
            ? s.initialDirection
            : [delta_x * scaler, delta_y * scaler];
        state.current = tslib_1.__assign({}, state.current, { time: time, xy: [pageX, pageY], initialDirection: initialDirection, delta: [delta_x, delta_y], local: [
                s.lastLocal[0] + pageX - s.initial[0],
                s.lastLocal[1] + pageY - s.initial[1]
            ], velocity: time - s.time === 0 ? s.velocity : velocity, distance: distance, direction: [x_dist * scaler, y_dist * scaler], previous: s.xy });
    }
    function onMove(e) {
        if (pressed.current && callbackRefs.current.onMove) {
            callbackRefs.current.onMove(state.current, e);
        }
    }
    function onRelease(e) {
        var s = state.current;
        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });
        if (callbackRefs.current.onRelease) {
            callbackRefs.current.onRelease(state.current, e);
        }
        grantedTouch = null;
    }
    function onTerminationRequest(e) {
        return callbackRefs.current.onTerminationRequest
            ? callbackRefs.current.onTerminationRequest(state.current, e)
            : true;
    }
    function onTerminate(e) {
        var s = state.current;
        state.current = tslib_1.__assign({}, state.current, { lastLocal: s.local });
        if (callbackRefs.current.onTerminate) {
            callbackRefs.current.onTerminate(state.current, e);
        }
    }
    function handleMoveMouse(e) {
        if (isMouseEnabled()) {
            handleMove(e);
        }
    }
    function handleMoveMouseCapture(e) {
        if (isMouseEnabled()) {
            handleMoveCapture(e);
        }
    }
    function handleEndMouse(e) {
        if (isMouseEnabled()) {
            handleEnd(e);
        }
    }
    React.useEffect(function () { return unbindGlobalMouseEvents; }, []);
    function terminateCurrentResponder() {
        if (grantedTouch) {
            grantedTouch.onTerminate();
            grantedTouch = null;
        }
    }
    function getCurrentResponder() {
        return grantedTouch;
    }
    var touchEvents = {
        onTouchStart: handleStart,
        onTouchEnd: handleEnd,
        onTouchMove: handleMove,
        onTouchStartCapture: handleStartCapture,
        onTouchMoveCapture: handleMoveCapture
    };
    var mouseEvents = enableMouse
        ? {
            onMouseDown: function (e) {
                if (isMouseEnabled()) {
                    handleStart(e);
                }
            },
            onMouseDownCapture: function (e) {
                if (isMouseEnabled()) {
                    handleStartCapture(e);
                }
            }
        }
        : {};
    return {
        bind: tslib_1.__assign({}, touchEvents, mouseEvents),
        terminateCurrentResponder: terminateCurrentResponder,
        getCurrentResponder: getCurrentResponder
    };
}

var initialTransform = "translateX(0px) translateY(0px) scale(1)";
var getScale = linearConversion([0, 400], [1, 0.4]);
var scaleClamp = clamp(0.4, 1);
/**
 * Image component
 * @param param0
 */
var ImageEnlarger = function (_a) {
    var _b = _a.zoomed, zoomed = _b === void 0 ? false : _b, renderLoading = _a.renderLoading, _c = _a.overlayColor, overlayColor = _c === void 0 ? "rgba(255,255,255,0.8)" : _c, enlargedSrc = _a.enlargedSrc, onRequestClose = _a.onRequestClose, _d = _a.style, style = _d === void 0 ? {} : _d, src = _a.src, other = tslib_1.__rest(_a, ["zoomed", "renderLoading", "overlayColor", "enlargedSrc", "onRequestClose", "style", "src"]);
    var ref = React.useRef(null);
    var prevZoom = usePrevious(zoomed);
    var _e = React.useState(false), animating = _e[0], setAnimating = _e[1];
    var cloneRef = React.useRef(null);
    var _f = React.useState(false), cloneLoaded = _f[0], setCloneLoaded = _f[1];
    var prevCloneLoaded = usePrevious(cloneLoaded);
    var _g = React.useState(zoomed), hasRequestedZoom = _g[0], setHasRequestedZoom = _g[1];
    // this allows us to lazily load our cloned image
    React.useEffect(function () {
        if (!hasRequestedZoom && zoomed) {
            setHasRequestedZoom(true);
        }
    }, [hasRequestedZoom, zoomed]);
    // disable scrolling while zooming is taking place
    useScrollLock(zoomed || animating);
    /**
     * We basically only use this to imperatively set the
     * visibility of the thumbnail
     */
    var _h = reactSpring.useSpring(function () { return ({
        opacity: 1,
        immediate: true
    }); }), thumbProps = _h[0], setThumbProps = _h[1];
    // set overlay opacity
    var _j = reactSpring.useSpring(function () { return ({
        opacity: zoomed ? 1 : 0
    }); }), overlay = _j[0], setOverlay = _j[1];
    // our cloned image spring
    var _k = reactSpring.useSpring(function () { return ({
        opacity: 0,
        transform: initialTransform,
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        immediate: true,
        config: reactSpring.config.stiff
    }); }), props = _k[0], set = _k[1];
    /**
     * Handle drag movement
     */
    function onMove(_a) {
        var delta = _a.delta;
        var scale = scaleClamp(getScale(Math.abs(delta[1])));
        // we use this to alter the y-position to ensure the image
        // scales under our cursor / pointer
        var diffHeight = ((1 - scale) * cloneRef.current.height) / 2;
        var ty = delta[1] - diffHeight * (delta[1] > 0 ? 1 : -1);
        set({
            transform: "translateX(" + delta[0] *
                0.8 + "px) translateY(" + ty + "px) scale(" + scale + ")",
            immediate: true
        });
        setOverlay({ opacity: scale, immediate: true });
    }
    /**
     * Handle release - we almost always close
     * @param param0
     */
    function onEnd(_a) {
        var delta = _a.delta;
        if (Math.abs(delta[1]) > 20 && onRequestClose) {
            onRequestClose();
        }
        else {
            // reset
            set({ transform: initialTransform, immediate: false });
            setOverlay({ opacity: 1, immediate: false });
        }
    }
    // our gesture binding helper
    var bind = useGestureResponder({
        onStartShouldSet: function () { return false; },
        onMoveShouldSet: function () {
            if (!zoomed) {
                return false;
            }
            return true;
        },
        onMove: onMove,
        onRelease: onEnd,
        onTerminate: onEnd
    }).bind;
    /**
     * Basic logic for determining positions. A bit of a mess tbh,
     * but that often comes when mixing imperative logic w/
     * react's declarative nature.
     */
    var generatePositions = React.useCallback(function (immediate) {
        if (immediate === void 0) { immediate = false; }
        // any time this prop changes, we update our position
        if (ref.current && cloneLoaded) {
            var rect = ref.current.getBoundingClientRect();
            var cloneSize = {
                width: cloneRef.current.naturalWidth,
                height: cloneRef.current.naturalHeight
            };
            var thumbDimensions = {
                x: rect.left,
                y: rect.top,
                w: rect.width,
                h: rect.height
            };
            var clonedDimensions = getTargetDimensions(cloneSize.width, cloneSize.height);
            var initialSize = getInitialClonedDimensions(thumbDimensions, clonedDimensions);
            var zoomingIn = (!prevZoom && zoomed) || (!prevCloneLoaded && cloneLoaded);
            var zoomingOut = prevZoom && !zoomed;
            // handle zooming in
            if (zoomingIn && !immediate) {
                setThumbProps({ opacity: 0, immediate: true });
                set({
                    opacity: 1,
                    immediate: true,
                    transform: "translateX(" + initialSize.translateX + "px) translateY(" + initialSize.translateY + "px) scale(" + initialSize.scale + ")",
                    left: clonedDimensions.x,
                    top: clonedDimensions.y,
                    width: clonedDimensions.w,
                    height: clonedDimensions.h,
                    onRest: function () { }
                });
                set({
                    transform: initialTransform,
                    immediate: false
                });
                // handle zooming out
            }
            else if (zoomingOut) {
                setAnimating(true);
                set({
                    transform: "translateX(" + initialSize.translateX + "px) translateY(" + initialSize.translateY + "px) scale(" + initialSize.scale + ")",
                    immediate: false,
                    onRest: function () {
                        setThumbProps({ opacity: 1, immediate: true });
                        set({ opacity: 0, immediate: true });
                        setAnimating(false);
                    }
                });
                // handle resizing
            }
            else if (immediate) {
                set({
                    immediate: true,
                    transform: initialTransform,
                    left: clonedDimensions.x,
                    top: clonedDimensions.y,
                    width: clonedDimensions.w,
                    height: clonedDimensions.h,
                    onRest: function () { }
                });
            }
            setOverlay({ opacity: zoomed ? 1 : 0 });
        }
    }, [
        zoomed,
        cloneLoaded,
        ref,
        cloneRef,
        prevCloneLoaded,
        hasRequestedZoom,
        prevZoom
    ]);
    // we need to update our fixed positioning when resizing
    // this should probably be debounced
    var onResize = React.useCallback(function () {
        generatePositions(true);
    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);
    // update our various positions
    React.useEffect(function () {
        generatePositions();
        if (zoomed)
            window.addEventListener("resize", onResize);
        return function () {
            window.removeEventListener("resize", onResize);
        };
    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "EnlargedImage" },
            React.createElement("div", { className: "EnlargedImage__container", style: { position: "relative", display: "inline-block" } },
                React.createElement(reactSpring.animated.img, tslib_1.__assign({ className: "EnlargedImage__Image", src: src, style: tslib_1.__assign({ cursor: "zoom-in", maxWidth: "100%", height: "auto", opacity: thumbProps.opacity }, style), ref: ref }, other)),
                !cloneLoaded && zoomed && renderLoading)),
        hasRequestedZoom && (React.createElement("div", tslib_1.__assign({ className: "EnlargedImage__enlarged-container" }, bind, { "aria-hidden": !zoomed, onClick: onRequestClose, style: {
                pointerEvents: zoomed ? "auto" : "none",
                position: "fixed",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
                zIndex: 90,
                cursor: "zoom-out"
            } }),
            React.createElement(reactSpring.animated.div, { className: "EnlargedImage__overlay", style: {
                    opacity: overlay.opacity,
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: overlayColor
                } }),
            React.createElement(reactSpring.animated.img, { className: "EnlargedImage__clone", onLoad: function () {
                    setCloneLoaded(true);
                }, style: {
                    pointerEvents: "none",
                    zIndex: 100,
                    position: "absolute",
                    opacity: props.opacity,
                    transform: props.transform,
                    left: props.left,
                    top: props.top,
                    width: props.width,
                    height: props.height
                }, ref: cloneRef, src: enlargedSrc || src })))));
};
/**
 * Get the original dimensions of the clone so that it appears
 * in the same place as the original image
 * @param o origin
 * @param t target
 */
function getInitialClonedDimensions(o, t) {
    var scale = o.w / t.w;
    var translateX = o.x + o.w / 2 - (t.x + t.w / 2);
    var translateY = o.y + o.h / 2 - (t.y + t.h / 2);
    return {
        scale: scale,
        translateX: translateX,
        translateY: translateY
    };
}
/**
 * Get the target dimensions / position of the image when
 * it's zoomed in
 *
 * @param iw (image width)
 * @param ih (image height)
 * @param padding
 */
function getTargetDimensions(iw, ih, padding) {
    if (padding === void 0) { padding = 0; }
    var vp = getViewport();
    var target = scaleToBounds(iw, ih, vp.width - padding, vp.height - padding);
    var left = vp.width / 2 - target.width / 2;
    var top = vp.height / 2 - target.height / 2;
    return {
        x: left,
        y: top,
        w: target.width,
        h: target.height
    };
}
/**
 * Scale numbers to bounds given max dimensions while
 * maintaining the original aspect ratio
 *
 * @param ow
 * @param oh
 * @param mw
 * @param mh
 */
function scaleToBounds(ow, oh, mw, mh) {
    var scale = Math.min(mw / ow, mh / oh);
    if (scale > 1)
        scale = 1;
    return {
        width: ow * scale,
        height: oh * scale
    };
}
/**
 * Server-safe measurement of the viewport size
 */
function getViewport() {
    if (typeof window !== "undefined") {
        return { width: window.innerWidth, height: window.innerHeight };
    }
    return { width: 0, height: 0 };
}
/**
 * Create a basic linear conversion fn
 */
function linearConversion(a, b) {
    var o = a[1] - a[0];
    var n = b[1] - b[0];
    return function (x) {
        return ((x - a[0]) * n) / o + b[0];
    };
}
/**
 * Create a clamp
 * @param max
 * @param min
 */
function clamp(min, max) {
    return function (x) {
        if (x > max)
            return max;
        if (x < min)
            return min;
        return x;
    };
}

module.exports = ImageEnlarger;
//# sourceMappingURL=index.js.map

{"code":"import * as tslib_1 from \"tslib\";\r\nimport * as React from \"react\";\r\nimport { useSpring, animated, config } from \"react-spring\";\r\nimport { usePrevious } from \"./use-previous\";\r\nimport { useGestureResponder } from \"react-gesture-responder\";\r\nimport useScrollLock from \"use-scroll-lock\";\r\nvar initialTransform = \"translateX(0px) translateY(0px) scale(1)\";\r\nvar getScale = linearConversion([0, 400], [1, 0.4]);\r\nvar scaleClamp = clamp(0.4, 1);\r\n/**\r\n * Image component\r\n * @param param0\r\n */\r\nvar ImageEnlarger = function (_a) {\r\n    var _b = _a.zoomed, zoomed = _b === void 0 ? false : _b, renderLoading = _a.renderLoading, _c = _a.overlayColor, overlayColor = _c === void 0 ? \"rgba(255,255,255,0.8)\" : _c, enlargedSrc = _a.enlargedSrc, onRequestClose = _a.onRequestClose, _d = _a.style, style = _d === void 0 ? {} : _d, src = _a.src, other = tslib_1.__rest(_a, [\"zoomed\", \"renderLoading\", \"overlayColor\", \"enlargedSrc\", \"onRequestClose\", \"style\", \"src\"]);\r\n    var ref = React.useRef(null);\r\n    var prevZoom = usePrevious(zoomed);\r\n    var _e = React.useState(false), animating = _e[0], setAnimating = _e[1];\r\n    var cloneRef = React.useRef(null);\r\n    var _f = React.useState(false), cloneLoaded = _f[0], setCloneLoaded = _f[1];\r\n    var prevCloneLoaded = usePrevious(cloneLoaded);\r\n    var _g = React.useState(zoomed), hasRequestedZoom = _g[0], setHasRequestedZoom = _g[1];\r\n    // this allows us to lazily load our cloned image\r\n    React.useEffect(function () {\r\n        if (!hasRequestedZoom && zoomed) {\r\n            setHasRequestedZoom(true);\r\n        }\r\n    }, [hasRequestedZoom, zoomed]);\r\n    // disable scrolling while zooming is taking place\r\n    useScrollLock(zoomed || animating);\r\n    /**\r\n     * We basically only use this to imperatively set the\r\n     * visibility of the thumbnail\r\n     */\r\n    var _h = useSpring(function () { return ({\r\n        opacity: 1,\r\n        immediate: true\r\n    }); }), thumbProps = _h[0], setThumbProps = _h[1];\r\n    // set overlay opacity\r\n    var _j = useSpring(function () { return ({\r\n        opacity: zoomed ? 1 : 0\r\n    }); }), overlay = _j[0], setOverlay = _j[1];\r\n    // our cloned image spring\r\n    var _k = useSpring(function () { return ({\r\n        opacity: 0,\r\n        transform: initialTransform,\r\n        left: 0,\r\n        top: 0,\r\n        width: 0,\r\n        height: 0,\r\n        immediate: true,\r\n        config: config.stiff\r\n    }); }), props = _k[0], set = _k[1];\r\n    /**\r\n     * Handle drag movement\r\n     */\r\n    function onMove(_a) {\r\n        var delta = _a.delta;\r\n        var scale = scaleClamp(getScale(Math.abs(delta[1])));\r\n        // we use this to alter the y-position to ensure the image\r\n        // scales under our cursor / pointer\r\n        var diffHeight = ((1 - scale) * cloneRef.current.height) / 2;\r\n        var ty = delta[1] - diffHeight * (delta[1] > 0 ? 1 : -1);\r\n        set({\r\n            transform: \"translateX(\" + delta[0] *\r\n                0.8 + \"px) translateY(\" + ty + \"px) scale(\" + scale + \")\",\r\n            immediate: true\r\n        });\r\n        setOverlay({ opacity: scale, immediate: true });\r\n    }\r\n    /**\r\n     * Handle release - we almost always close\r\n     * @param param0\r\n     */\r\n    function onEnd(_a) {\r\n        var delta = _a.delta;\r\n        if (Math.abs(delta[1]) > 20 && onRequestClose) {\r\n            onRequestClose();\r\n        }\r\n        else {\r\n            // reset\r\n            set({ transform: initialTransform, immediate: false });\r\n            setOverlay({ opacity: 1, immediate: false });\r\n        }\r\n    }\r\n    // our gesture binding helper\r\n    var bind = useGestureResponder({\r\n        onStartShouldSet: function () { return false; },\r\n        onMoveShouldSet: function () {\r\n            if (!zoomed) {\r\n                return false;\r\n            }\r\n            return true;\r\n        },\r\n        onMove: onMove,\r\n        onRelease: onEnd,\r\n        onTerminate: onEnd\r\n    }).bind;\r\n    /**\r\n     * Basic logic for determining positions. A bit of a mess tbh,\r\n     * but that often comes when mixing imperative logic w/\r\n     * react's declarative nature.\r\n     */\r\n    var generatePositions = React.useCallback(function (immediate) {\r\n        if (immediate === void 0) { immediate = false; }\r\n        // any time this prop changes, we update our position\r\n        if (ref.current && cloneLoaded) {\r\n            var rect = ref.current.getBoundingClientRect();\r\n            var cloneSize = {\r\n                width: cloneRef.current.naturalWidth,\r\n                height: cloneRef.current.naturalHeight\r\n            };\r\n            var thumbDimensions = {\r\n                x: rect.left,\r\n                y: rect.top,\r\n                w: rect.width,\r\n                h: rect.height\r\n            };\r\n            var clonedDimensions = getTargetDimensions(cloneSize.width, cloneSize.height);\r\n            var initialSize = getInitialClonedDimensions(thumbDimensions, clonedDimensions);\r\n            var zoomingIn = (!prevZoom && zoomed) || (!prevCloneLoaded && cloneLoaded);\r\n            var zoomingOut = prevZoom && !zoomed;\r\n            // handle zooming in\r\n            if (zoomingIn && !immediate) {\r\n                setThumbProps({ opacity: 0, immediate: true });\r\n                set({\r\n                    opacity: 1,\r\n                    immediate: true,\r\n                    transform: \"translateX(\" + initialSize.translateX + \"px) translateY(\" + initialSize.translateY + \"px) scale(\" + initialSize.scale + \")\",\r\n                    left: clonedDimensions.x,\r\n                    top: clonedDimensions.y,\r\n                    width: clonedDimensions.w,\r\n                    height: clonedDimensions.h,\r\n                    onRest: function () { }\r\n                });\r\n                set({\r\n                    transform: initialTransform,\r\n                    immediate: false\r\n                });\r\n                // handle zooming out\r\n            }\r\n            else if (zoomingOut) {\r\n                setAnimating(true);\r\n                set({\r\n                    transform: \"translateX(\" + initialSize.translateX + \"px) translateY(\" + initialSize.translateY + \"px) scale(\" + initialSize.scale + \")\",\r\n                    immediate: false,\r\n                    onRest: function () {\r\n                        setThumbProps({ opacity: 1, immediate: true });\r\n                        set({ opacity: 0, immediate: true });\r\n                        setAnimating(false);\r\n                    }\r\n                });\r\n                // handle resizing\r\n            }\r\n            else if (immediate) {\r\n                set({\r\n                    immediate: true,\r\n                    transform: initialTransform,\r\n                    left: clonedDimensions.x,\r\n                    top: clonedDimensions.y,\r\n                    width: clonedDimensions.w,\r\n                    height: clonedDimensions.h,\r\n                    onRest: function () { }\r\n                });\r\n            }\r\n            setOverlay({ opacity: zoomed ? 1 : 0 });\r\n        }\r\n    }, [\r\n        zoomed,\r\n        cloneLoaded,\r\n        ref,\r\n        cloneRef,\r\n        prevCloneLoaded,\r\n        hasRequestedZoom,\r\n        prevZoom\r\n    ]);\r\n    // we need to update our fixed positioning when resizing\r\n    // this should probably be debounced\r\n    var onResize = React.useCallback(function () {\r\n        generatePositions(true);\r\n    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);\r\n    // update our various positions\r\n    React.useEffect(function () {\r\n        generatePositions();\r\n        if (zoomed)\r\n            window.addEventListener(\"resize\", onResize);\r\n        return function () {\r\n            window.removeEventListener(\"resize\", onResize);\r\n        };\r\n    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);\r\n    return (React.createElement(React.Fragment, null,\r\n        React.createElement(\"div\", { className: \"EnlargedImage\" },\r\n            React.createElement(\"div\", { className: \"EnlargedImage__container\", style: { position: \"relative\", display: \"inline-block\" } },\r\n                React.createElement(animated.img, tslib_1.__assign({ className: \"EnlargedImage__Image\", src: src, style: tslib_1.__assign({ cursor: \"zoom-in\", maxWidth: \"100%\", height: \"auto\", opacity: thumbProps.opacity }, style), ref: ref }, other)),\r\n                !cloneLoaded && zoomed && renderLoading)),\r\n        hasRequestedZoom && (React.createElement(\"div\", tslib_1.__assign({ className: \"EnlargedImage__enlarged-container\" }, bind, { \"aria-hidden\": !zoomed, onClick: onRequestClose, style: {\r\n                pointerEvents: zoomed ? \"auto\" : \"none\",\r\n                position: \"fixed\",\r\n                top: 0,\r\n                left: 0,\r\n                bottom: 0,\r\n                right: 0,\r\n                zIndex: 90,\r\n                cursor: \"zoom-out\"\r\n            } }),\r\n            React.createElement(animated.div, { className: \"EnlargedImage__overlay\", style: {\r\n                    opacity: overlay.opacity,\r\n                    position: \"absolute\",\r\n                    top: 0,\r\n                    left: 0,\r\n                    right: 0,\r\n                    bottom: 0,\r\n                    backgroundColor: overlayColor\r\n                } }),\r\n            React.createElement(animated.img, { className: \"EnlargedImage__clone\", onLoad: function () {\r\n                    setCloneLoaded(true);\r\n                }, style: {\r\n                    pointerEvents: \"none\",\r\n                    zIndex: 100,\r\n                    position: \"absolute\",\r\n                    opacity: props.opacity,\r\n                    transform: props.transform,\r\n                    left: props.left,\r\n                    top: props.top,\r\n                    width: props.width,\r\n                    height: props.height\r\n                }, ref: cloneRef, src: enlargedSrc || src })))));\r\n};\r\n/**\r\n * Get the original dimensions of the clone so that it appears\r\n * in the same place as the original image\r\n * @param o origin\r\n * @param t target\r\n */\r\nfunction getInitialClonedDimensions(o, t) {\r\n    var scale = o.w / t.w;\r\n    var translateX = o.x + o.w / 2 - (t.x + t.w / 2);\r\n    var translateY = o.y + o.h / 2 - (t.y + t.h / 2);\r\n    return {\r\n        scale: scale,\r\n        translateX: translateX,\r\n        translateY: translateY\r\n    };\r\n}\r\n/**\r\n * Get the target dimensions / position of the image when\r\n * it's zoomed in\r\n *\r\n * @param iw (image width)\r\n * @param ih (image height)\r\n * @param padding\r\n */\r\nfunction getTargetDimensions(iw, ih, padding) {\r\n    if (padding === void 0) { padding = 0; }\r\n    var vp = getViewport();\r\n    var target = scaleToBounds(iw, ih, vp.width - padding, vp.height - padding);\r\n    var left = vp.width / 2 - target.width / 2;\r\n    var top = vp.height / 2 - target.height / 2;\r\n    return {\r\n        x: left,\r\n        y: top,\r\n        w: target.width,\r\n        h: target.height\r\n    };\r\n}\r\n/**\r\n * Scale numbers to bounds given max dimensions while\r\n * maintaining the original aspect ratio\r\n *\r\n * @param ow\r\n * @param oh\r\n * @param mw\r\n * @param mh\r\n */\r\nfunction scaleToBounds(ow, oh, mw, mh) {\r\n    var scale = Math.min(mw / ow, mh / oh);\r\n    if (scale > 1)\r\n        scale = 1;\r\n    return {\r\n        width: ow * scale,\r\n        height: oh * scale\r\n    };\r\n}\r\n/**\r\n * Server-safe measurement of the viewport size\r\n */\r\nfunction getViewport() {\r\n    if (typeof window !== \"undefined\") {\r\n        return { width: window.innerWidth, height: window.innerHeight };\r\n    }\r\n    return { width: 0, height: 0 };\r\n}\r\n/**\r\n * Create a basic linear conversion fn\r\n */\r\nfunction linearConversion(a, b) {\r\n    var o = a[1] - a[0];\r\n    var n = b[1] - b[0];\r\n    return function (x) {\r\n        return ((x - a[0]) * n) / o + b[0];\r\n    };\r\n}\r\n/**\r\n * Create a clamp\r\n * @param max\r\n * @param min\r\n */\r\nfunction clamp(min, max) {\r\n    return function (x) {\r\n        if (x > max)\r\n            return max;\r\n        if (x < min)\r\n            return min;\r\n        return x;\r\n    };\r\n}\r\nexport default ImageEnlarger;\r\n","dts":{"name":"/Users/bmcmahen/Web/react-image-enlarger/index.d.ts","writeByteOrderMark":false,"text":"import * as React from \"react\";\r\nexport interface ImageEnlargerProps extends React.HTMLAttributes<any> {\r\n    zoomed: boolean;\r\n    onClick: () => void;\r\n    enlargedSrc?: string;\r\n    overlayColor?: string;\r\n    renderLoading?: React.ReactNode;\r\n    onRequestClose: () => void;\r\n    src: string;\r\n}\r\n/**\r\n * Image component\r\n * @param param0\r\n */\r\ndeclare const ImageEnlarger: React.FunctionComponent<ImageEnlargerProps>;\r\nexport default ImageEnlarger;\r\n"}}

import * as tslib_1 from "tslib";
import * as React from "react";
import { useSpring, animated, config } from "react-spring";
import { usePrevious } from "./use-previous";
import { useGestureResponder } from "react-gesture-responder";
import useScrollLock from "use-scroll-lock";
var initialTransform = "translateX(0px) translateY(0px) scale(1)";
var getScale = linearConversion([0, 400], [1, 0.4]);
var scaleClamp = clamp(0.4, 1);
/**
 * Image component
 * @param param0
 */
var ImageEnlarger = function (_a) {
    var _b = _a.zoomed, zoomed = _b === void 0 ? false : _b, renderLoading = _a.renderLoading, _c = _a.overlayColor, overlayColor = _c === void 0 ? "rgba(255,255,255,0.8)" : _c, enlargedSrc = _a.enlargedSrc, onRequestClose = _a.onRequestClose, _d = _a.style, style = _d === void 0 ? {} : _d, src = _a.src, other = tslib_1.__rest(_a, ["zoomed", "renderLoading", "overlayColor", "enlargedSrc", "onRequestClose", "style", "src"]);
    var ref = React.useRef(null);
    var prevZoom = usePrevious(zoomed);
    var _e = React.useState(false), animating = _e[0], setAnimating = _e[1];
    var cloneRef = React.useRef(null);
    var _f = React.useState(false), cloneLoaded = _f[0], setCloneLoaded = _f[1];
    var prevCloneLoaded = usePrevious(cloneLoaded);
    var _g = React.useState(zoomed), hasRequestedZoom = _g[0], setHasRequestedZoom = _g[1];
    // this allows us to lazily load our cloned image
    React.useEffect(function () {
        if (!hasRequestedZoom && zoomed) {
            setHasRequestedZoom(true);
        }
    }, [hasRequestedZoom, zoomed]);
    // disable scrolling while zooming is taking place
    useScrollLock(zoomed || animating);
    /**
     * We basically only use this to imperatively set the
     * visibility of the thumbnail
     */
    var _h = useSpring(function () { return ({
        opacity: 1,
        immediate: true
    }); }), thumbProps = _h[0], setThumbProps = _h[1];
    // set overlay opacity
    var _j = useSpring(function () { return ({
        opacity: zoomed ? 1 : 0
    }); }), overlay = _j[0], setOverlay = _j[1];
    // our cloned image spring
    var _k = useSpring(function () { return ({
        opacity: 0,
        transform: initialTransform,
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        immediate: true,
        config: config.stiff
    }); }), props = _k[0], set = _k[1];
    /**
     * Handle drag movement
     */
    function onMove(_a) {
        var delta = _a.delta;
        var scale = scaleClamp(getScale(Math.abs(delta[1])));
        // we use this to alter the y-position to ensure the image
        // scales under our cursor / pointer
        var diffHeight = ((1 - scale) * cloneRef.current.height) / 2;
        var ty = delta[1] - diffHeight * (delta[1] > 0 ? 1 : -1);
        set({
            transform: "translateX(" + delta[0] *
                0.8 + "px) translateY(" + ty + "px) scale(" + scale + ")",
            immediate: true
        });
        setOverlay({ opacity: scale, immediate: true });
    }
    /**
     * Handle release - we almost always close
     * @param param0
     */
    function onEnd(_a) {
        var delta = _a.delta;
        if (Math.abs(delta[1]) > 20 && onRequestClose) {
            onRequestClose();
        }
        else {
            // reset
            set({ transform: initialTransform, immediate: false });
            setOverlay({ opacity: 1, immediate: false });
        }
    }
    // our gesture binding helper
    var bind = useGestureResponder({
        onStartShouldSet: function () { return false; },
        onMoveShouldSet: function () {
            if (!zoomed) {
                return false;
            }
            return true;
        },
        onMove: onMove,
        onRelease: onEnd,
        onTerminate: onEnd
    }).bind;
    /**
     * Basic logic for determining positions. A bit of a mess tbh,
     * but that often comes when mixing imperative logic w/
     * react's declarative nature.
     */
    var generatePositions = React.useCallback(function (immediate) {
        if (immediate === void 0) { immediate = false; }
        // any time this prop changes, we update our position
        if (ref.current && cloneLoaded) {
            var rect = ref.current.getBoundingClientRect();
            var cloneSize = {
                width: cloneRef.current.naturalWidth,
                height: cloneRef.current.naturalHeight
            };
            var thumbDimensions = {
                x: rect.left,
                y: rect.top,
                w: rect.width,
                h: rect.height
            };
            var clonedDimensions = getTargetDimensions(cloneSize.width, cloneSize.height);
            var initialSize = getInitialClonedDimensions(thumbDimensions, clonedDimensions);
            var zoomingIn = (!prevZoom && zoomed) || (!prevCloneLoaded && cloneLoaded);
            var zoomingOut = prevZoom && !zoomed;
            // handle zooming in
            if (zoomingIn && !immediate) {
                setThumbProps({ opacity: 0, immediate: true });
                set({
                    opacity: 1,
                    immediate: true,
                    transform: "translateX(" + initialSize.translateX + "px) translateY(" + initialSize.translateY + "px) scale(" + initialSize.scale + ")",
                    left: clonedDimensions.x,
                    top: clonedDimensions.y,
                    width: clonedDimensions.w,
                    height: clonedDimensions.h,
                    onRest: function () { }
                });
                set({
                    transform: initialTransform,
                    immediate: false
                });
                // handle zooming out
            }
            else if (zoomingOut) {
                setAnimating(true);
                set({
                    transform: "translateX(" + initialSize.translateX + "px) translateY(" + initialSize.translateY + "px) scale(" + initialSize.scale + ")",
                    immediate: false,
                    onRest: function () {
                        setThumbProps({ opacity: 1, immediate: true });
                        set({ opacity: 0, immediate: true });
                        setAnimating(false);
                    }
                });
                // handle resizing
            }
            else if (immediate) {
                set({
                    immediate: true,
                    transform: initialTransform,
                    left: clonedDimensions.x,
                    top: clonedDimensions.y,
                    width: clonedDimensions.w,
                    height: clonedDimensions.h,
                    onRest: function () { }
                });
            }
            setOverlay({ opacity: zoomed ? 1 : 0 });
        }
    }, [
        zoomed,
        cloneLoaded,
        ref,
        cloneRef,
        prevCloneLoaded,
        hasRequestedZoom,
        prevZoom
    ]);
    // we need to update our fixed positioning when resizing
    // this should probably be debounced
    var onResize = React.useCallback(function () {
        generatePositions(true);
    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);
    // update our various positions
    React.useEffect(function () {
        generatePositions();
        if (zoomed)
            window.addEventListener("resize", onResize);
        return function () {
            window.removeEventListener("resize", onResize);
        };
    }, [zoomed, cloneLoaded, ref, prevCloneLoaded, prevZoom]);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "EnlargedImage" },
            React.createElement("div", { className: "EnlargedImage__container", style: { position: "relative", display: "inline-block" } },
                React.createElement(animated.img, tslib_1.__assign({ className: "EnlargedImage__Image", src: src, style: tslib_1.__assign({ cursor: "zoom-in", maxWidth: "100%", height: "auto", opacity: thumbProps.opacity }, style), ref: ref }, other)),
                !cloneLoaded && zoomed && renderLoading)),
        hasRequestedZoom && (React.createElement("div", tslib_1.__assign({ className: "EnlargedImage__enlarged-container" }, bind, { "aria-hidden": !zoomed, onClick: onRequestClose, style: {
                pointerEvents: zoomed ? "auto" : "none",
                position: "fixed",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
                zIndex: 90,
                cursor: "zoom-out"
            } }),
            React.createElement(animated.div, { className: "EnlargedImage__overlay", style: {
                    opacity: overlay.opacity,
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: overlayColor
                } }),
            React.createElement(animated.img, { className: "EnlargedImage__clone", onLoad: function () {
                    setCloneLoaded(true);
                }, style: {
                    pointerEvents: "none",
                    zIndex: 100,
                    position: "absolute",
                    opacity: props.opacity,
                    transform: props.transform,
                    left: props.left,
                    top: props.top,
                    width: props.width,
                    height: props.height
                }, ref: cloneRef, src: enlargedSrc || src })))));
};
/**
 * Get the original dimensions of the clone so that it appears
 * in the same place as the original image
 * @param o origin
 * @param t target
 */
function getInitialClonedDimensions(o, t) {
    var scale = o.w / t.w;
    var translateX = o.x + o.w / 2 - (t.x + t.w / 2);
    var translateY = o.y + o.h / 2 - (t.y + t.h / 2);
    return {
        scale: scale,
        translateX: translateX,
        translateY: translateY
    };
}
/**
 * Get the target dimensions / position of the image when
 * it's zoomed in
 *
 * @param iw (image width)
 * @param ih (image height)
 * @param padding
 */
function getTargetDimensions(iw, ih, padding) {
    if (padding === void 0) { padding = 0; }
    var vp = getViewport();
    var target = scaleToBounds(iw, ih, vp.width - padding, vp.height - padding);
    var left = vp.width / 2 - target.width / 2;
    var top = vp.height / 2 - target.height / 2;
    return {
        x: left,
        y: top,
        w: target.width,
        h: target.height
    };
}
/**
 * Scale numbers to bounds given max dimensions while
 * maintaining the original aspect ratio
 *
 * @param ow
 * @param oh
 * @param mw
 * @param mh
 */
function scaleToBounds(ow, oh, mw, mh) {
    var scale = Math.min(mw / ow, mh / oh);
    if (scale > 1)
        scale = 1;
    return {
        width: ow * scale,
        height: oh * scale
    };
}
/**
 * Server-safe measurement of the viewport size
 */
function getViewport() {
    if (typeof window !== "undefined") {
        return { width: window.innerWidth, height: window.innerHeight };
    }
    return { width: 0, height: 0 };
}
/**
 * Create a basic linear conversion fn
 */
function linearConversion(a, b) {
    var o = a[1] - a[0];
    var n = b[1] - b[0];
    return function (x) {
        return ((x - a[0]) * n) / o + b[0];
    };
}
/**
 * Create a clamp
 * @param max
 * @param min
 */
function clamp(min, max) {
    return function (x) {
        if (x > max)
            return max;
        if (x < min)
            return min;
        return x;
    };
}
export default ImageEnlarger;
